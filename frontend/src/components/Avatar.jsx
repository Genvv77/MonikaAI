/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { useChat } from "../hooks/useChat";

export function Avatar(props) {
  const { nodes, scene } = useGLTF("/models/monika_v99.glb");
  const { message, onMessagePlayed } = useChat();

  const [audio, setAudio] = useState();
  const [lipsync, setLipsync] = useState();

  // --- 1. NETTOYAGE ANIMATIONS ---
  const { animations } = useGLTF("/models/animations.glb");
  const group = useRef();
  const { actions } = useAnimations(animations, group);
  const [animation, setAnimation] = useState("Idle");

  useEffect(() => {
    if (animations) {
      animations.forEach((clip) => {
        clip.tracks = clip.tracks.filter((track) => {
          // On supprime tout ce qui touche aux morphs pour éviter les conflits
          return !track.name.includes("morphTargetInfluences");
        });
      });
    }
  }, [animations]);

  // --- 2. AUDIO ---
  useEffect(() => {
    // 1. Si pas de message, on reset
    if (!message) {
      setAnimation("Idle");
      return;
    }

    // 2. On lance l'animation (même sans audio, elle doit bouger un peu)
    setAnimation(message.animation || "Idle");
    setLipsync(message.lipsync);

    // 3. CAS SANS AUDIO (Le fix de sécurité)
    if (!message.audio) {
        console.log("⚠️ Message sans audio détecté. Passage automatique dans 3s.");
        setTimeout(() => {
            setAnimation("Idle");
            onMessagePlayed(); 
        }, 3000); // On laisse le temps de lire la bulle
        return;   // On arrête ici pour ce message
    }

    // 4. CAS AVEC AUDIO (Normal)
    const newAudio = new Audio("data:audio/mp3;base64," + message.audio);
    newAudio.volume = 1.0;
    
    newAudio.play().catch((e) => {
        console.error("Erreur lecture audio:", e);
        // Si l'audio plante à la lecture, on force le passage
        onMessagePlayed();
    });

    setAudio(newAudio);
    
    newAudio.onended = () => {
      setAnimation("Idle");
      onMessagePlayed();
    };
    
  }, [message]);

  useEffect(() => {
    const anim = actions[animation] ? animation : "Idle";
    if (actions[anim]) {
      actions[anim].reset().fadeIn(0.5).play();
      return () => actions[anim]?.fadeOut(0.5);
    }
  }, [animation, actions]);

  // --- 3. SYNCRO DENTS & VISAGE ---
  useFrame(() => {
    if (!audio || audio.paused) {
      // Fermeture propre
      if (nodes.Wolf3D_Head) {
          const idx = nodes.Wolf3D_Head.morphTargetDictionary["mouthOpen"];
          if (idx !== undefined) nodes.Wolf3D_Head.morphTargetInfluences[idx] = 0;
      }
      if (nodes.Wolf3D_Teeth) {
          const idx = nodes.Wolf3D_Teeth.morphTargetDictionary["mouthOpen"];
          if (idx !== undefined) nodes.Wolf3D_Teeth.morphTargetInfluences[idx] = 0;
      }
      return;
    }

    const currentAudioTime = audio.currentTime;
    let target = 0;

    if (lipsync) {
      for (let i = 0; i < lipsync.mouthCues.length; i++) {
        const cue = lipsync.mouthCues[i];
        if (currentAudioTime >= cue.start && currentAudioTime <= cue.end) {
          // Mapping simplifié pour mouthOpen
          switch (cue.value) {
            case "X": target = 0; break;
            case "A": target = 1.0; break;
            case "B": target = 0; break;
            case "C": target = 0.5; break;
            case "D": target = 0.8; break;
            case "E": target = 0.5; break;
            case "F": target = 0.3; break;
            case "G": target = 0.5; break;
            case "H": target = 0.6; break;
            default: target = 0; break;
          }
          break;
        }
      }
    }

    // --- APPLICATION CRITIQUE ---
    
    // 1. VISAGE (Wolf3D_Head)
    if (nodes.Wolf3D_Head) {
        const headIdx = nodes.Wolf3D_Head.morphTargetDictionary["mouthOpen"];
        if (headIdx !== undefined) {
            nodes.Wolf3D_Head.morphTargetInfluences[headIdx] = THREE.MathUtils.lerp(
                nodes.Wolf3D_Head.morphTargetInfluences[headIdx],
                target,
                0.8
            );
        }
        // Petit sourire pour la forme
        const smileIdx = nodes.Wolf3D_Head.morphTargetDictionary["mouthSmile"];
        if (smileIdx !== undefined) nodes.Wolf3D_Head.morphTargetInfluences[smileIdx] = 0.2;
    }

    // 2. DENTS (Wolf3D_Teeth) - C'est ICI que ça se joue
    // On applique EXACTEMENT la même ouverture aux dents
    if (nodes.Wolf3D_Teeth) {
        const teethIdx = nodes.Wolf3D_Teeth.morphTargetDictionary["mouthOpen"];
        if (teethIdx !== undefined) {
            nodes.Wolf3D_Teeth.morphTargetInfluences[teethIdx] = THREE.MathUtils.lerp(
                nodes.Wolf3D_Teeth.morphTargetInfluences[teethIdx],
                target,
                0.8
            );
        }
    }
  });

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips || nodes.mixamorigHips || nodes.root} />
      {Object.keys(nodes).map((name) => {
        if (nodes[name].isSkinnedMesh) {
          return (
            <skinnedMesh
              key={name}
              geometry={nodes[name].geometry}
              material={nodes[name].material}
              skeleton={nodes[name].skeleton}
              morphTargetDictionary={nodes[name].morphTargetDictionary}
              morphTargetInfluences={nodes[name].morphTargetInfluences}
            />
          );
        }
        return null;
      })}
    </group>
  );
}

useGLTF.preload("/models/monika_v99.glb");
useGLTF.preload("/models/animations.glb");